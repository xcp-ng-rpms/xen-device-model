diff --git a/hw/vgpu_fb.c b/hw/vgpu_fb.c
index 42cce8b..238b7df 100644
--- a/hw/vgpu_fb.c
+++ b/hw/vgpu_fb.c
@@ -13,6 +13,7 @@
 #include "exec-all.h"
 
 #include "qemu-timer.h"
+#include "qemu-xen.h"
 
 #pragma pack(1)
 
@@ -23,6 +24,7 @@ typedef struct shared_surface {
     uint32_t    height;
     uint32_t    depth;
     uint32_t    update;
+    uint64_t    vram_addr;
 } shared_surface_t;
 
 #pragma pack(0)
@@ -44,7 +46,8 @@ typedef struct vgpu_fb_state {
 } vgpu_fb_state;
 
 #define DEMU_FIFO_PATH     "/var/xen/vgpu/%d/fifo"
-#define DEMU_FIFO_TIMEOUT   (60 * 5)
+#define DEMU_FIFO_TIMEOUT  (60 * 5)
+#define DEMU_SURFACE_PATH  "/xen.vgpu.%d"
 
 static bool out_of_time = false;
 
@@ -116,6 +119,49 @@ unlink_and_exit:
     return fd;
 }
 
+static int open_surface_shm(shared_surface_t **shared)
+{
+    int rc = 0;
+    int shm_fd;
+    void *ptr;
+    char *sh_name;
+
+    if (asprintf(&sh_name, DEMU_SURFACE_PATH, domid) < 0)
+        return -errno;
+
+    /* open the shared memory segment */
+    shm_fd = shm_open(sh_name, O_RDONLY, 0666);
+    if (shm_fd < 0) {
+        rc = -errno;
+        fprintf(stderr, "shm_open error %s\n", strerror(-rc));
+        goto out;
+    }
+
+    /* now map the shared memory segment in the address space of the process */
+    ptr = mmap(0, sizeof(shared_surface_t), PROT_READ, MAP_SHARED, shm_fd, 0);
+    if (ptr == MAP_FAILED) {
+        rc = -errno;
+        fprintf(stderr, "mmap error %s\n", strerror(-rc));
+    } else {
+        *shared = ptr;
+    }
+
+    if (close(shm_fd)) {
+        if (!rc)
+            rc = -errno;
+        fprintf(stderr, "close error %s\n", strerror(errno));
+    }
+
+    if (shm_unlink(sh_name)) {
+        if (!rc)
+            rc = -errno;
+        fprintf(stderr, "shm_unlink error %s\n", strerror(errno));
+    }
+out:
+    free(sh_name);
+    return rc;
+}
+
 static int create_demu_fifo(void)
 {
     char *buffer;
@@ -212,7 +258,9 @@ vgpu_fb_init(void)
     xen_pfn_t pfn[n];
     int i;
     vgpu_fb_state *s;
-    int fifo_fd;
+    int fifo_fd, rc;
+    int defaulted = 0;
+    uint64_t address;
 
     s = qemu_mallocz(sizeof(vgpu_fb_state));
     if (!s)
@@ -230,20 +278,25 @@ vgpu_fb_init(void)
         exit(1);
     }
 
+    rc = open_surface_shm(&s->shared);
+    if (rc) {
+        fprintf(stderr, "Failed to open shared surface.  %s", strerror(-rc));
+        exit(1);
+    }
+
+    address = s->shared->vram_addr;
+
     for (i = 0; i < n; i++)
-        pfn[i] = (SURFACE_RESERVED_ADDRESS >> TARGET_PAGE_BITS) + i;
+        pfn[i] = (address >> TARGET_PAGE_BITS) + i;
 
     s->surface_buffer = xc_map_foreign_pages(xc_handle, domid,
                                              PROT_READ | PROT_WRITE,
                                              pfn, n);
     if (s->surface_buffer == NULL) {
-        fprintf(stderr, "mmap failed\n");
+        fprintf(stderr, "mmap failed. address = 0x%jx %s\n", 
+                        address, defaulted?"(Default)":"");
         exit(1);
     }
 
-    s->shared = (shared_surface_t *)(s->surface_buffer +
-                                     SURFACE_RESERVED_SIZE -
-                                     TARGET_PAGE_SIZE);
-
     s->surface_fd = fifo_fd;
 }
