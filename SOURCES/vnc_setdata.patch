diff --git a/vnc.c b/vnc.c
index ed0240e..c691ab2 100644
--- a/vnc.c
+++ b/vnc.c
@@ -255,6 +255,7 @@ struct VncDisplay
 struct VncState
 {
     int csock;
+    int resize;
     DisplayState *ds;
     struct VncDirtyBuffer dirty;
     VncDisplay *vd;
@@ -374,6 +375,8 @@ static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)
     w = MIN(x + w, s->ds->width) - x;
     h = MIN(h, s->ds->height);
 
+    VNC_DEBUG("VNC: update (%d,%d,%d,%d)\n", x,y,w,h);
+
     for (; y < h; y++)
 	for (i = 0; i < w; i += 16)
             dirty_set_bit(&s->dirty, (x + i) / 16, y);
@@ -538,6 +541,7 @@ static void vnc_dpy_resize(DisplayState *ds)
 
     if (!vd->server)
         return;
+    VNC_DEBUG("VNC: resized frame buffer to (%d,%d)\n", ds_get_width(ds), ds_get_height(ds));
 
     size_changed = vnc_update_surface(vd);
 
@@ -546,12 +550,7 @@ static void vnc_dpy_resize(DisplayState *ds)
         vnc_colordepth(vs);
         if (size_changed) {
             if (vs->csock != -1 && vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {
-                vnc_write_u8(vs, 0);  /* msg id */
-                vnc_write_u8(vs, 0);
-                vnc_write_u16(vs, 1); /* number of rects */
-                vnc_framebuffer_update(vs, 0, 0, ds_get_width(ds), ds_get_height(ds),
-                        VNC_ENCODING_DESKTOPRESIZE);
-                vnc_flush(vs);
+                vs->resize = 1;
             }
         }
         dirty_resize(&vs->dirty, ds_get_width(ds), ds_get_height(ds));
@@ -758,7 +757,6 @@ static int vnc_zlib_stop(VncState *vs)
     if (zstream->opaque != vs) {
         int err;
 
-        VNC_DEBUG("VNC: initializing zlib stream %d\n", stream_id);
         VNC_DEBUG("VNC: opaque = %p | vs = %p\n", zstream->opaque, vs);
         zstream->zalloc = Z_NULL;
         zstream->zfree = Z_NULL;
@@ -866,6 +864,17 @@ static int vnc_update_client(VncState *vs, int has_dirty)
 	int n_rectangles;
 	int saved_offset;
 
+    if (vs->resize) {
+        vnc_write_u8(vs, 0);  /* msg id */
+        vnc_write_u8(vs, 0);
+        vnc_write_u16(vs, 1); /* number of rects */
+        vnc_framebuffer_update(vs, 0, 0, ds_get_width(vs->ds), ds_get_height(vs->ds), VNC_ENCODING_DESKTOPRESIZE);
+        vnc_flush(vs);
+        vs->resize = 0;
+        vs->need_update = 0;
+        vs->missed_update = 0;
+        return 0;
+    }
         if (vs->output.offset && !vs->audio_cap && !vs->force_update)
             /* kernel send buffers are full -> drop frames to throttle */
             return 0;
@@ -1735,7 +1744,14 @@ static void pixel_format_message (VncState *vs) {
 
 static void vnc_dpy_setdata(DisplayState *ds)
 {
-    /* We don't have to do anything */
+    /* The guest has changed where it is writing to */
+
+    VncDisplay *vd = ds->opaque;
+    vd->guest.ds->data =  ds->surface->data;
+
+    VNC_DEBUG("VNC: new frame buffer %p\n", vd->guest.ds->data);
+
+    dirty_set_all(&vd->guest.dirty);
 }
 
 static void vnc_colordepth(VncState *vs)
@@ -2604,7 +2620,6 @@ static void vnc_refresh(void *opaque)
     VncDisplay *vd = opaque;
     VncState *vs = NULL, *vn = NULL;
     int has_dirty = 0, rects = 0;
-
     if (!vd->server)
         return;
 
